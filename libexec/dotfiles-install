#!/usr/bin/env bash
# Summary: Install dotfiles
#
# Usage: dotfiles install [arguments] <path>

# Bomb out if we hit an error, ever
set -e
[ -n "$DOTFILES_DEBUG" ] && set -x

parse_options() {
  OPTIONS=()
  ARGUMENTS=()
  local arg option index

  for arg in "$@"; do
    if [ "${arg:0:1}" = "-" ]; then
      if [ "${arg:1:1}" = "-" ]; then
        OPTIONS[${#OPTIONS[*]}]="${arg:2}"
      else
        index=1
        while option="${arg:$index:1}"; do
          [ -n "$option" ] || break
          OPTIONS[${#OPTIONS[*]}]="$option"
          index=$(($index+1))
        done
      fi
    else
      ARGUMENTS[${#ARGUMENTS[*]}]="$arg"
    fi
  done
}

jobs_await() {
  local pid="$1"
  local spinners=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')

  # Check if running in interactive terminal
  if [ -t 1 ]; then
    # Interactive mode: show spinner
    while kill -0 "$pid" 2>/dev/null; do
      for spinner in "${spinners[@]}"; do
        printf "  %s  \r" "$spinner" >&2
        sleep 0.05
        kill -0 "$pid" 2>/dev/null || break 2
      done
    done
  else
    # Non-interactive mode (CI): simple wait without spinner
    while kill -0 "$pid" 2>/dev/null; do
      sleep 0.1
    done
  fi
}

get_dest_base() {
  if [ -n "$DRY_RUN" ]; then
    echo "/tmp/sandbox"
  else
    echo "$HOME"
  fi
}

should_skip_existing() {
  local dest="$1"
  [ -z "$FORCE" ] && { [ -f "$dest" ] || [ -L "$dest" ] || [ -d "$dest" ]; }
}

remove_existing() {
  local dest="$1"
  [ -f "$dest" ] || [ -L "$dest" ] || [ -d "$dest" ] && rm -f "$dest"
}

create_symlink() {
  local source="$1"
  local dest="$2"

  if should_skip_existing "$dest"; then
    return
  fi

  [ -n "$FORCE" ] && remove_existing "$dest"

  mkdir -p "$(dirname "$dest")"
  ln -sf "$source" "$dest"

  [ -n "$VERBOSE" ] && echo "$dest -> $source"
}

install_directory_files() {
  local source_path="$1"
  local dest_base="$2"

  while IFS= read -r -d '' file; do
    local relative_path="${file#$source_path/}"
    local dest_file="$dest_base/$relative_path"

    create_symlink "$file" "$dest_file"
  done < <(find "$source_path" \( -type f -o -type l \) -print0)
}

run_installation() {
  unset VERBOSE
  unset DRY_RUN
  unset FORCE

  parse_options "$@"
  for option in "${OPTIONS[@]}"; do
    case "$option" in
      "dry-run" )
        DRY_RUN=true
        ;;
      "v" | "verbose" )
        VERBOSE=true
        ;;
      "f" | "force" )
        FORCE=true
        ;;
    esac
  done

  echo "Processing ${#ARGUMENTS[@]} target(s)..."

  for target in "${ARGUMENTS[@]}"; do
    echo "Target: $target"
    files=()

    if [ -f "$target" ]; then
      files=("$target")
      echo "  Single file target"
    elif [ -d "$target" ]; then
      echo "  Directory target, searching for dotfiles..."
      while IFS= read -r file; do
        files+=("$file")
        echo "    Found: $file"
      done < <(find "$target" -maxdepth 1 -name ".*" -not -name .git | sed -e 's|//|/|')
      echo "  Total files found: ${#files[@]}"
    else
      echo "Error: Target $target is neither a file nor a directory" >&2
      exit 1
    fi

    if [ ${#files[@]} -eq 0 ]; then
      echo "Warning: No dotfiles found in $target" >&2
      continue
    fi

    for dotfile in "${files[@]}"; do
      name="$(basename "$dotfile")"

      # Resolve absolute path with error checking
      dotfile_dir="$(dirname "$dotfile")"
      original_dir="$(pwd)"
      if ! cd "$dotfile_dir" 2>/dev/null; then
        echo "Error: Cannot access directory $dotfile_dir" >&2
        exit 1
      fi
      source_path="$(pwd)/$name"
      cd "$original_dir"

      # For ALL directories in bundle/, use file-level symlinks
      if [ -d "$source_path" ]; then
        dest_base="$(get_dest_base)/$name"
        install_directory_files "$source_path" "$dest_base"
      else
        # For regular files (not directories), symlink directly
        dest="$(get_dest_base)/$name"
        create_symlink "$source_path" "$dest"
      fi
    done
  done
}

# Run with spinner in interactive mode, directly in CI
if [ -t 1 ]; then
  run_installation "$@" &
  pid=$!
  jobs_await $pid
  wait $pid
else
  echo "Running dotfiles installation (CI mode)..."
  run_installation "$@"
  echo "Installation completed successfully"
fi

exit 0

# vim:set ts=8 sts=2 sw=2 tw=0:
# vim:set ft=sh:
