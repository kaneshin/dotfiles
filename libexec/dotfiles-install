#!/usr/bin/env bash
# Summary: Install dotfiles
#
# Usage: dotfiles install [arguments] <path>

# Bomb out if we hit an error, ever
set -e
[ -n "$DOTFILES_DEBUG" ] && set -x

parse_options() {
  OPTIONS=()
  ARGUMENTS=()
  local arg option index

  for arg in "$@"; do
    if [ "${arg:0:1}" = "-" ]; then
      if [ "${arg:1:1}" = "-" ]; then
        OPTIONS[${#OPTIONS[*]}]="${arg:2}"
      else
        index=1
        while option="${arg:$index:1}"; do
          [ -n "$option" ] || break
          OPTIONS[${#OPTIONS[*]}]="$option"
          index=$(($index+1))
        done
      fi
    else
      ARGUMENTS[${#ARGUMENTS[*]}]="$arg"
    fi
  done
}

jobs_await() {
  local pid="$1"
  local spinners=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')

  while jobs -rp | grep -q "$pid"; do
    for spinner in "${spinners[@]}"; do
      printf "  %s  \r" "$spinner" >&2
      sleep 0.05
    done
  done
}

get_dest_base() {
  if [ -n "$DRY_RUN" ]; then
    echo "/tmp/sandbox"
  else
    echo "$HOME"
  fi
}

should_skip_existing() {
  local dest="$1"
  [ -z "$FORCE" ] && { [ -f "$dest" ] || [ -L "$dest" ] || [ -d "$dest" ]; }
}

remove_existing() {
  local dest="$1"
  [ -f "$dest" ] || [ -L "$dest" ] || [ -d "$dest" ] && rm -f "$dest"
}

create_symlink() {
  local source="$1"
  local dest="$2"

  if should_skip_existing "$dest"; then
    return
  fi

  [ -n "$FORCE" ] && remove_existing "$dest"

  mkdir -p "$(dirname "$dest")"
  ln -sf "$source" "$dest"

  [ -n "$VERBOSE" ] && echo "$dest -> $source"
}

install_directory_files() {
  local source_path="$1"
  local dest_base="$2"

  while IFS= read -r -d '' file; do
    local relative_path="${file#$source_path/}"
    local dest_file="$dest_base/$relative_path"

    create_symlink "$file" "$dest_file"
  done < <(find "$source_path" \( -type f -o -type l \) -print0)
}

{
  unset VERBOSE
  unset DRY_RUN
  unset FORCE

  parse_options "$@"
  for option in "${OPTIONS[@]}"; do
    case "$option" in
      "dry-run" )
        DRY_RUN=true
        ;;
      "v" | "verbose" )
        VERBOSE=true
        ;;
      "f" | "force" )
        FORCE=true
        ;;
    esac
  done

  for target in "${ARGUMENTS[@]}"; do
    files=()

    if [ -f "$target" ]; then
      files=("$target")
    elif [ -d "$target" ]; then
      while IFS= read -r file; do
        files+=("$file")
      done < <(find "$target" -maxdepth 1 -name ".*" -not -name .git | sed -e 's|//|/|')
    fi

    [ ${#files[@]} -eq 0 ] && continue

    for dotfile in "${files[@]}"; do
      name="$(basename "$dotfile")"
      source_path="$(cd "$(dirname "$dotfile")" && pwd)/$name"

      # For ALL directories in bundle/, use file-level symlinks
      if [ -d "$source_path" ]; then
        dest_base="$(get_dest_base)/$name"
        install_directory_files "$source_path" "$dest_base"
      else
        # For regular files (not directories), symlink directly
        dest="$(get_dest_base)/$name"
        create_symlink "$source_path" "$dest"
      fi
    done
  done
} &
pid=$!
jobs_await $pid
wait $pid

exit 0

# vim:set ts=8 sts=2 sw=2 tw=0:
# vim:set ft=sh:
