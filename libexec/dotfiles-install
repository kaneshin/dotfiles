#!/usr/bin/env bash
# Summary: Install dotfiles
#
# Usage: dotfiles install [arguments] <path>

# Bomb out if we hit an error, ever
set -e
[ -n "$DOTFILES_DEBUG" ] && set -x

parse_options() {
  OPTIONS=()
  ARGUMENTS=()
  local arg option index

  for arg in "$@"; do
    if [ "${arg:0:1}" = "-" ]; then
      if [ "${arg:1:1}" = "-" ]; then
        OPTIONS[${#OPTIONS[*]}]="${arg:2}"
      else
        index=1
        while option="${arg:$index:1}"; do
          [ -n "$option" ] || break
          OPTIONS[${#OPTIONS[*]}]="$option"
          index=$(($index+1))
        done
      fi
    else
      ARGUMENTS[${#ARGUMENTS[*]}]="$arg"
    fi
  done
}

jobs_await() {
  local pid="$1"
  local spinners=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
  while true; do
    for spinner in ${spinners[@]}; do
      printf "  $spinner  \r" > /dev/stderr
      sleep 0.05
    done
    if ! jobs -rp | grep "$pid" > /dev/null; then
      break
    fi
  done
}

install_config_directory() {
  local source_path="$1"

  # Find all files recursively within .config
  while IFS= read -r -d '' file; do
    # Calculate relative path from .config directory
    relative_path="${file#$source_path/}"

    if [ -n "$DRY_RUN" ]; then
      dest_file="/tmp/sandbox/.config/$relative_path"
    else
      dest_file="$HOME/.config/$relative_path"
    fi

    # Skip if exists (unless --force)
    if [ ! -n "$FORCE" ]; then
      [ -f "$dest_file" ] && continue
      [ -L "$dest_file" ] && continue
    else
      [ -f "$dest_file" ] && rm -f "$dest_file"
      [ -L "$dest_file" ] && rm -f "$dest_file"
    fi

    # Create parent directory structure
    [ ! -d "$(dirname $dest_file)" ] && mkdir -p $(dirname $dest_file)

    # Symlink the file
    ln -sf "$file" "$dest_file"

    if [ -n "$VERBOSE" ]; then
      echo "$dest_file -> $file"
    fi
  done < <(find "$source_path" -type f -print0)
}

{
  unset VERBOSE
  unset DRY_RUN
  unset FORCE

  parse_options "$@"
  for option in "${OPTIONS[@]}"; do
    case "$option" in
      "dry-run" )
        DRY_RUN=true
        ;;
      "v" | "verbose" )
        VERBOSE=true
        ;;
      "f" | "force" )
        FORCE=true
        ;;
    esac
  done

  for target in "${ARGUMENTS[@]}"; do
    unset files
    if [ -f $target ]; then
      files=($target)
    elif [ -d $target ]; then
      declare -a files=$(find $target -maxdepth 1 -name ".*" \
        -not -name .git \
        | sed -e 's|//|/|')
    fi
    [ "$files" = "" ] && continue;

    for dotfile in ${files[@]}; do
      name=$(basename $dotfile)
      source_path=$(cd $(dirname $dotfile);pwd)/$name

      # Special case: .config directory - symlink files individually
      if [ "$name" = ".config" ] && [ -d "$source_path" ]; then
        install_config_directory "$source_path"
        continue  # Skip normal processing for .config
      fi

      # Normal processing for all other files/directories
      if [ -n "$DRY_RUN" ]; then
        dest=/tmp/sandbox
      else
        dest=$HOME
      fi
      dest="$dest/$name"
      if [ ! -n "$FORCE" ]; then
        [ -f "$dest" ] && continue
        [ -d "$dest" ] && continue
      else
        [ -d "$dest" ] && rm -f "$dest"
      fi
      [ ! -d "$(dirname $dest)" ] && mkdir -p $(dirname $dest)
      ln -sf "$source_path" "$dest"
      if [ -n "$VERBOSE" ]; then
        echo "$dest -> $source_path"
      fi
    done
  done
} &
pid=$!
jobs_await $pid
wait $pid

exit 0

# vim:set ts=8 sts=2 sw=2 tw=0:
# vim:set ft=sh:
